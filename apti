#!/usr/bin/env ruby
# encoding: utf-8

=begin
****************************************************************************

  Apti is a frontend for aptitude with improved presentation of packages.

  Copyright (C) 2012 by Florent Lévigne <florent.levigne at mailoo dot com>
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

****************************************************************************
=end

APTI_VERSION      = "0.2.1-dev (2012-10-14)"

$VERBOSE          = true          # enable warnings

COLOR_INSTALL     = "\033[1;32m"  # green
COLOR_REMOVE      = "\033[1;31m"  # red
COLOR_DESCRIPTION = "\033[1;30m"  # gray
COLOR_END         = "\033[0m"

USE_SUDO          = false         # if false, use root password



#-----------------------------#
#          functions          #
#-----------------------------#

#
# help
#
def help
  puts "usage: #{File.basename $0} commande"
  puts "Commandes:"
  puts "  update"
  puts "  safe-upgrade"
  puts "  search package"
  puts "  install package"
  puts "  remove package"
  puts "  others aptitude commande..."
  puts "  --stats"
end


#
# version
#
def version
  puts "apti #{APTI_VERSION}"
end


#
# Return an hash with largest size of package name (max["name"]),
# and largest size of package version (max["version"]).
#
def get_max_package packages 
  max_name_size     = 0
  max_version_size  = 0

  packages.each do |ele|
    if ele =~ /(([[:alnum:]]|-|\+|\.|\{|\})*) \[(([[:alnum:]]|-|\+|\.|:|~)*)/

      package_name    = $1
      package_version = $3

      if package_name.length > max_name_size
        max_name_size = package_name.length
      end

      if package_version.length > max_version_size
        max_version_size = package_version.length
      end

    end
  end

  max             = Hash.new
  max["name"]     = max_name_size
  max["version"]  = max_version_size

  return max
end


#
# upgrade
#
def upgrade full_upgrade = false
  if full_upgrade
    aptitude_string = `aptitude full-upgrade -V -s --allow-untrusted --assume-yes`
  else
    aptitude_string = `aptitude safe-upgrade -V -s --allow-untrusted --assume-yes`
  end

  # if problem with dependencies, use aptitude
  if aptitude_string.include? "1)"

    if USE_SUDO
      if full_upgrade
        system "sudo aptitude full-upgrade"
      else
        system "sudo aptitude safe-upgrade"
      end

    else
      if full_upgrade
        system "su -c 'aptitude full-upgrade'"
      else
        system "su -c 'aptitude safe-upgrade'"
      end
    end

    exit 0

  # if there is no package to upgrade
  elsif !aptitude_string.include? ':'
    puts "System is up to date."
    exit 0
  end

  packages = [[]]

  first_install = false
  first_remove  = false
  first_update  = false

  # split packages
  packages = aptitude_string.split ']'

  max             = get_max_package packages
  largest_name    = max["name"]
  largest_version = max["version"]

  packages.each do |ele|

    # if we have a package to install
    # ex: freepats{a} [20060219-1
    if ele =~ /(([[:alnum:]]|-|\+|\.)*\{a\}) \[(.*)/
      package_name    = $1
      package_version = $3

      if !first_install
        puts "\033[1mNew package(s) to install:\033[0m"
        first_install = true
      end

      print "install: #{package_name}"

      # print spaces between name and version of the package
      (largest_name - package_name.length).times do
        print ' '
      end

      puts " #{COLOR_INSTALL}#{package_version}#{COLOR_END}"

    # if we have a package to remove
    # ex: gcj-4.6-base{u} [4.6.3-1]
    elsif ele =~ /(([[:alnum:]]|-|\+|\.)*\{u\}) \[(.*)/
      package_name    = $1
      package_version = $3

      if !first_remove
        puts "\n\033[1mPackage(s) to remove:\033[0m"
        first_remove = true
      end

      print "remove: #{package_name} "

      # print spaces between name and version of the package
      (largest_name - package_name.length).times do
        print ' '
      end

      puts " #{COLOR_REMOVE}#{package_version}#{COLOR_END}"

    # if we have a package to upgrade
    # ex: php5 [5.3.10-2 -> 5.4.0-3
    elsif ele =~ /(([[:alnum:]]|-|\+|\.)*) \[(.*) -> (.*)/
      
      package_name        = $1
      version_installed   = $3
      version_to_install  = $4

      if !first_update
        puts "\n\033[1mPackage(s) to update:\033[0m"
        first_update = true
      end
      
      # package name
      print "update: #{package_name} "

      # print spaces between name and version of the package
      (largest_name - package_name.length).times do
        print ' '
      end

      # version installed
      print " #{COLOR_REMOVE}#{version_installed}#{COLOR_END} "

      # print spaces between version installed and version to install
      (largest_version - version_installed.length).times do
        print ' '
      end

      # version to install
      puts "-> #{COLOR_INSTALL}#{version_to_install}#{COLOR_END}"
    end

  end

  answer = ''
  while !answer.downcase.eql? 'y' and !answer.downcase.eql? 'n'
    print "\n\033[1mContinue the upgrade ? (Y/n)\033[0m "
    answer = STDIN.gets.chomp
    if answer.empty?
      answer = 'y'
    end
  end

  if answer.downcase.equal? 'n'
    exit 0
  end

  if USE_SUDO
    if full_upgrade
      system "sudo aptitude full-upgrade"
    else
      system "sudo aptitude safe-upgrade"
    end

  else
    if full_upgrade
      system "su -c 'aptitude full-upgrade'"
    else
      system "su -c 'aptitude safe-upgrade'"
    end
  end
end


#
# search
#
def search package
  aptitude_string = `aptitude search --disable-columns #{package}`

  # for each package
  aptitude_string.each_line do |package|
    
    package_str = package.split "- "

    package_name = package_str.first
    package_description = ""

    # construct the description (all after the first '-')
    name_passed = false
    package_str.each do |str|
      if !name_passed
        name_passed = true
      else
        package_description.concat "- #{str }"
      end
    end

    # if the package is installed, we display it in color
    if package_name.split.first.include? 'i'
      puts "#{COLOR_INSTALL}#{package_name}#{COLOR_END}"
    else
      puts package_name
    end

    # display the description
    package_description.chomp!
    if !package_description.empty?
      puts "\t#{COLOR_DESCRIPTION}#{package_description}#{COLOR_END}"
    end
    
  end
end


#
# install
#
def install package
  aptitude_string = `aptitude install -V -s --allow-untrusted --assume-yes #{package}`

  # if problem with dependencies, wrong name given,
  # or trying to install a virtual package : use aptitude
  if aptitude_string.include? "1)" or aptitude_string.include? '«'
    if USE_SUDO
      system "sudo aptitude install #{package}"
    else
      system "su -c 'aptitude install #{package}'"
    end
    exit 0

  # if the package is already installed
  elsif !aptitude_string.include? ':'
    puts "Package(s) already installed."
    exit 0
  end

  packages = [[]]

  first_install = false

  # split packages
  packages = aptitude_string.split ']'

  max             = get_max_package packages
  largest_name    = max["name"]

  packages.each do |ele|

    # if we have a package to install
    # ex: freepats{a} [20060219-1 or freepats [20060219-1
    if ele =~ /(([[:alnum:]]|-|\+|\.|\{|\})*) \[(.*)/
      package_name    = $1
      package_version = $3

      if !first_install
        puts "\033[1mPackage(s) to install:\033[0m"
        first_install = true
      end

      print "install: #{package_name}"

      # print spaces between name and version of the package
      (largest_name - package_name.length).times do
        print ' '
      end
      
      puts " #{COLOR_INSTALL}#{package_version}#{COLOR_END}"

    end
  end

  answer = ''
  while !answer.downcase.eql? 'y' and !answer.downcase.eql? 'n'
    print "\n\033[1mContinue the installation ? (Y/n)\033[0m "
    answer = STDIN.gets.chomp
    if answer.empty?
      answer = 'y'
    end
  end

  if answer.downcase == 'n'
    exit 0
  end

  if USE_SUDO
    system "sudo aptitude install #{package}"
  else
    system "su -c 'aptitude install #{package}'"
  end
end


#
# remove
#
def remove package
  aptitude_string = `aptitude remove -V -s --assume-yes #{package}`

  # if problem with dependencies, wrong name given,
  # or trying to remove a virtual package : use aptitude
  if aptitude_string.include? "1)" or aptitude_string.include? '«'
    if USE_SUDO
      system "sudo aptitude remove #{package}"
    else
      system "su -c 'aptitude remove #{package}'"
    end
    exit 0

  # if the package is not installed
  elsif !aptitude_string.include? ':'
    puts "Package(s) not installed."
    exit 0
  end

  packages = [[]]

  first_remove = false

  # split packages
  packages = aptitude_string.split ']'

  max             = get_max_package packages
  largest_name    = max["name"]

  packages.each do |ele|

    # if we have a package to remove
    # ex: freepats{u} [20060219-1 or freepats [20060219-1
    if ele =~ /(([[:alnum:]]|-|\+|\.|\{|\})*) \[(.*)/
      package_name    = $1
      package_version = $3

      if !first_remove
        puts "\033[1mPackage(s) to remove:\033[0m"
        first_remove = true
      end

      print "remove: #{package_name}"

      # print spaces between name and version of the package
      (largest_name - package_name.strip.length).times do
        print ' '
      end
      
      puts " #{COLOR_REMOVE}#{package_version}#{COLOR_END}"

    end
  end

  answer = ''
  while !answer.downcase.eql? 'y' and !answer.downcase.eql? 'n'
    print "\n\033[1mRemove these packages ? (Y/n)\033[0m "
    answer = STDIN.gets.chomp
    if answer.empty?
      answer = 'y'
    end
  end

  if answer.downcase == 'n'
    exit 0
  end

  if USE_SUDO
    system "sudo aptitude remove #{package}"
  else
    system "su -c 'aptitude remove #{package}'"
  end
end


#
# Print stats about packages
#
def stats
  packages_installed            = `dpkg --get-selections | grep install | grep -v deinstall | wc -l`
  packages_installed_explicitly = `aptitude search '~i !~M' | wc -l`
  cache_size                    = `du -sh /var/cache/apt/archives/ | cut -f 1`

  if File.exist? "/etc/debian_version"
    puts "Debian #{`cat /etc/debian_version`}\n"
  end

  puts "Total installed packages:         #{packages_installed}"
  puts "Explicitly installed packages:    #{packages_installed_explicitly}"
  puts "Space used by packages in cache:  #{cache_size}"
end



#-----------------------------#
#          execution          #
#-----------------------------#

case ARGV[0]

  when "safe-upgrade"
    upgrade

  when "upgrade"
    puts "Warning: upgrade is deprecated, use safe-upgrade."
    upgrade

  when "full-upgrade"
    upgrade true

  when "search"
    packages_to_search = ""
    first_argv_passed = false
    ARGV.each do |package|
      if !first_argv_passed
        first_argv_passed = true
      else
        packages_to_search += " #{package}"
      end
    end
    search packages_to_search

  when "update"
    if USE_SUDO
      system "sudo aptitude update"
    else
      system "su -c 'aptitude update'"
    end

  when "remove"
    packages_to_remove = ""
    first_argv_passed = false
    ARGV.each do |package|
      if !first_argv_passed
        first_argv_passed = true
      else
        packages_to_remove += " #{package}"
      end
    end
    remove packages_to_remove

  when "install"
    packages_to_install = ""
    first_argv_passed = false
    ARGV.each do |package|
      if !first_argv_passed
        first_argv_passed = true
      else
        packages_to_install += " #{package}"
      end
    end
    install packages_to_install

  when "--stats"
    stats

  when "--help"
    help

  when "--version"
    version

  # other aptitude command
  else
    if ARGV[0] != nil
      arg = ""
      ARGV.each do |ele|
        arg += "#{ele} "
      end
      system "aptitude #{arg}"
    else
      help
    end

end
