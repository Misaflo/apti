#!/usr/bin/env ruby
# encoding: utf-8

=begin
****************************************************************************

  Apti is a frontend for aptitude with improved presentation of packages.

  Copyright (C) 2012-2013 by Florent LÃ©vigne <florent.levigne at mailoo dot com>
  Copyright (C) 2013 by Julien Rosset <jul.rosset at gmail dot com>


  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

****************************************************************************
=end

# Configuration in ~/.config/apti/aptirc.yml (by default)

#
# Version of apti.
#
APTI_VERSION      = "0.4"
#
# Enable warnings ?
#
$VERBOSE          = true
#
# Constant for stopping color (Linux bash color notation).
#
COLOR_END         = "\e[0m"
#
# Operations needing superuser rights.
#
NEED_SUPERUSER_RIGHTS = ["install", "remove", "purge", "hold", "unhold", "keep", "reinstall",
                         "markauto", "unmarkauto", "build-depends", "build-dep", "forbid-version",
                         "update", "safe-upgrade", "full-upgrade", "keep-all", "forget-new",
                         "clean", "autoclean"]


#-----------------------------#
#          functions          #
#-----------------------------#

#
# Display help.
#
# @return [void]
def help
  puts "usage: #{File.basename $0} commande"
  puts "Commandes:"
  puts "  update"
  puts "  safe-upgrade"
  puts "  search package"
  puts "  install package"
  puts "  remove package"
  puts "  others aptitude commande..."
  puts "  stats"
end


#
# Display version.
#
# @return [void]
def version
  puts "apti #{APTI_VERSION}"
end


#
# Separate packages in analysis parts, and return a Hash as bellow :
#
#   Hash{max, Array<detail>}
#
#   max['name']           : length of largest name
#   max['version']['old'] : length of largest old (for upgrade) or current version
#   max['version']['new'] : length of the largest new version (only for upgrade)
#   max['size']['before'] : length of the size of the package, before the decimal
#   max['size']['after']  : length of the size of the package, after the decimal
#   max['size']['unit']   : length of the size's unit
#
#   detail['name']            : name of the package
#   detail['parameter']       : aptitude's information : a, u, p
#   detail['version']['old']  : old / current version of the package
#   detail['version']['new']  : new version of the package (only for upgrade)
#   detail['size']['before']  : size of the package, before the decimal
#   detail['size']['after']   : size of the package, after the decimal
#   detail['size']['unit']    : size's unit
#
# @param packages [Array<String>] List of packages
#
# @return [Hash{String => Hash{String => Fixnum, String, Hash{String => Fixnum, String}}}] Largest sizes and details of sections of package line : name, version
#   (old / current and new) and size (integer part, decimal part and unit)
def analysis_packages(packages)
  max                   = Hash.new
  max['name']           = 0
  max['version']        = Hash.new
  max['version']['old'] = 0
  max['version']['new'] = 0
  max['size']           = Hash.new
  max['size']['before'] = 0
  max['size']['after']  = 0
  max['size']['unit']   = 0

  details = Array.new

  packages.delete_if { |package| package == '' || package == "\n" }

  packages.each do |package|
    # ex: brasero-common{a} [3.8.0-2] <+11,2 MB>
    #                 name                  parameter           version_old           ->  version_new                 size_before                                   size_after          size_unit
    if package =~ /^([[:alnum:]+.:-]*)(?:\{([[:alpha:]])\})? \[([[:alnum:]+.:~-]*)(?: -> ([[:alnum:]+.:~-]*))?\](?: <([+-]?[[:digit:]]{1,3}(?:[ ,][[:digit:]]{3})*)([.,][[:digit:]]+)? ([[:alpha:]]+)>)?$/
      detail                   = Hash.new
      detail['name']           = $1
      detail['parameter']      = $2
      detail['version']        = Hash.new
      detail['version']['old'] = $3
      detail['version']['new'] = $4
      detail['size']           = Hash.new
      detail['size']['before'] = $5
      detail['size']['after']  = $6
      detail['size']['unit']   = $7

      if detail['name'].length > max['name']
        max['name'] = detail['name'].length
      end

      if detail['version']['old'].length > max['version']['old']
        max['version']['old'] = detail['version']['old'].length
      end
      if not detail['version']['new'].nil? and detail['version']['new'].length > max['version']['new']
        max['version']['new'] = detail['version']['new'].length
      end

      if not detail['size']['before'].nil? and detail['size']['before'].length > max['size']['before']
        max['size']['before'] = detail['size']['before'].length
      end
      if not detail['size']['after'].nil? and detail['size']['after'].length > max['size']['after']
        max['size']['after'] = detail['size']['after'].length
      end
      if not detail['size']['unit'].nil? and detail['size']['unit'].length > max['size']['unit']
        max['size']['unit'] = detail['size']['unit'].length
      end
    
      details << detail
    end
  end

  max['version']['all'] = max['version']['old'] + max['version']['new']
  if max['version']['new'] > 0
    max['version']['all'] += " -> ".length
  end

  out            = Hash.new
  out['max']     = max
  out['details'] = details

  return out
end


#
# Display all packages of an operation (install, upgrade or remove).
#
# @param packages       [Array<String>] List of packages (analysis_packages called automaticaly)
# @param operation      [String]        Operation requested : "Installing", "Upgrading" or "Removing"
# @param color          [String]        Color (Linux bash color notation) to use for old / current package version
# @param question       [String]        Question to ask for continuing operation after displaying packages list
# @param download_size  [String]        Aptitude's text about download sizes
#
# @return [void]
def display_packages(packages, operation, color, question, download_size)
  analysis = analysis_packages packages
  max      = analysis['max']
  details  = analysis['details']

  explicit    = []
  dep_install = []
  dep_remove  = []
  
  details.each do |detail|
    case detail['parameter']
    when 'a'
      dep_install << detail

    when 'u'
      dep_remove  << detail

    else
      explicit << detail
    end
  end

  print_header(max['name'], max['version']['all'])

  puts "\033[1m#{operation} :\033[0m"
  explicit.each { |detail| display_package_line(detail, max, color) }

  if not dep_install.empty?
    puts "\n\033[1mInstalling for dependencies :\033[0m"
    dep_install.each { |detail| display_package_line(detail, max, $color_install) }
  end

  if not dep_remove.empty?
    puts "\n\033[1mRemoving for unused :\033[0m"
    dep_remove.each { |detail| display_package_line(detail, max, $color_remove) }
  end

  # size to download and install
  puts "\n#{download_size}"

  answer = ''
  while (not answer.downcase.eql? 'y') and (not answer.downcase.eql? 'n')
    print "\n\033[1m#{question} ? (Y/n)\033[0m "
    answer = STDIN.gets.chomp
    if answer.empty?
      answer = 'y'
    end
  end

  return (answer.downcase.eql? 'y')
end


#
# Displaying the line of ONE package.
#
# @param line       [Hash{String => String, Hash{String => String}}]  Details of package to display
# @param max        [Hash{String => Fixnum, Hash{String => Fixnum}}]  Largest sizes of sections
# @param color      [String]                                          Color (Linux bash color notation) to use for old / current package version
#
# @return [void]
def display_package_line(line, max, color)
  print "  #{line['name']}"
  print "#{color}#{''.rjust((max['name'] - line['name'].length) + $spaces_between_columns)}#{line['version']['old']}#{COLOR_END}"

  if not line['version']['new'].nil?
    print "#{' -> '.rjust((max['version']['old'] - line['version']['old'].length) + ' -> '.length)}#{$color_install}#{line['version']['new']}#{COLOR_END}"
    rjust_size = max['version']['new'] - line['version']['new'].length
  else
    rjust_size = max['version']['all'] - line['version']['old'].length
  end

  if $display_packages_size and not line['size']['before'].nil?
    line_size_after_length = (line['size']['after'].nil? ? 0 : line['size']['after'].length)

    print "#{$color_description}"
    print "#{line['size']['before'].rjust(rjust_size + $spaces_between_columns + max['size']['before'])}"
    print "#{line['size']['after']}"
    print "#{line['size']['unit'].rjust((max['size']['after'] - line_size_after_length) + (max['size']['unit'] - line['size']['unit'].length) + line['size']['unit'].length + $spaces_between_unit)}"
    print "#{COLOR_END}"
  end
  
  print "\n"
end


#
# Print header for install, remove and upgrade.
#
# @param largest_name     [Fixnum]  Largest size of package name
# @param largest_version  [Fixnum]  Largest size of complete version (old / current AND new)
#
# @return [void]
def print_header(largest_name, largest_version)
  terminal_width  = `tput cols`.to_i

  # top line
  terminal_width.times do
    print '='
  end
  print "\n"

  # column's names
  header_package = "Package"
  header_version = "Version"
  header_size    = "Size"

  print "  #{header_package}"
  print "#{''.rjust(largest_name - header_package.length + $spaces_between_columns)}"
  print "#{header_version}"
  if $display_packages_size
    print "#{''.rjust(largest_version - header_version.length + $spaces_between_columns + 1)}"
    print "#{header_size}"
  end
  print "\n"

  # bottom line
  terminal_width.times do
    print '='
  end
  print "\n"
end


#
# Execute the command with superuser rights if needed.
#
# @param command    [String]  Command to execute
# @param no_confirm [Boolean] If true execute the command without asking confirmation (--assume-yes)
#
# @return [void]
def execute_command(command, no_confirm = false)
  if not NEED_SUPERUSER_RIGHTS.include? command.split[1]
    system command
  elsif `groups`.split.include? "sudo"
    if no_confirm and $no_confirm
      system "sudo #{command} --assume-yes"
    else
      system "sudo #{command}"
    end
  else
    if no_confirm and $no_confirm
      system "su -c '#{command} --assume-yes'"
    else
      system "su -c '#{command}'"
    end
  end
end


#
# Do upgrade (safe-upgrade or full-upgrade).
#
# @param packages     [String]  List of packages to upgrade
# @param full_upgrade [Boolean] True if full-upgrade, else safe-upgrade
#
# @return [void]
def upgrade(packages, full_upgrade = false)
  if full_upgrade
    aptitude_string = `aptitude full-upgrade -VZs --allow-untrusted --assume-yes #{packages}`
    command = "aptitude full-upgrade #{packages}"
  else
    aptitude_string = `aptitude safe-upgrade -VZs --allow-untrusted --assume-yes #{packages}`
    command = "aptitude safe-upgrade #{packages}"
  end
 
  # if problem with dependencies, use aptitude
  if aptitude_string.include? "1)"
    execute_command command
    exit 0

  # if there is no package to upgrade
  elsif not aptitude_string.include? ':'
    puts "System is up to date."
    exit 0
  end

  packages = []

  # split packages
  packages = aptitude_string.split(/ {2}/)

  if display_packages(packages, 'Upgrading', $color_remove, 'Continue the upgrade', aptitude_string.split(/\n/)[-2])
    execute_command(command, true)
  end
end


#
# Search packages.
#
# @param package [String] Package(s) to search.
#
# @return [void]
def search(package)
  aptitude_string = `aptitude search --disable-columns #{package}`
  terminal_width  = `tput cols`.to_i
  package_info_length = 6 # information size (i, p, A, ...) : 6 seems to be good

  # for each package
  aptitude_string.each_line do |package_line|

    package_str = package_line.split "- "

    package_name = package_str.first # ex: i A aptitude-common
    package_description = ""

    # construct the description (all after the first '-')
    name_passed = false
    package_str.each do |str|
      if not name_passed
        name_passed = true
      else
        package_description.concat "- #{str }"
      end
    end

    # informations of the package: i, p, A, ...
    package_info = package_name.split
    package_info.pop
    package_info = package_info.join(' ')

    # just the package name (without informations)
    package_name = package_name.split.last

    # display package informations
    print package_info

    # print spaces between package_info and package_name
    (package_info_length - package_info.length).times do
      print ' '
    end

    # display package name: if the package is installed, we display it in color
    if package_info.include? 'i'
      print "#{$color_install}#{package_name}#{COLOR_END}"
    else
      print package_name
    end

    # print spaces between package_name and package_description
    ($spaces_search - package_name.length).times do
      print ' '
    end

    size_of_line = package_info_length + $spaces_search + package_description.length

    # if description is too long, we shorten it
    if size_of_line > terminal_width
      package_description = package_description[0..(terminal_width - package_info_length - $spaces_search - 1)]
    end

    # display the description
    puts "#{$color_description}#{package_description.chomp}#{COLOR_END}"
  end
end


#
# Install packages.
#
# @param package [String] List of packages to install
#
# @return [void]
def install package
  aptitude_string = `aptitude install -VZs --allow-untrusted --assume-yes #{package}`
  command = "aptitude install #{package}"

  # if problem with dependencies, wrong name given,
  # or package already installed : display aptitude's message
  if (aptitude_string.include? "1)") or (not aptitude_string.include? ':')
    puts aptitude_string
    exit 0
  end

  packages = []

  # split packages
  packages = aptitude_string.split(/ {2}/)
  
  if display_packages(packages, 'Installing', $color_install, 'Continue the installation', aptitude_string.split(/\n/)[-2])
    execute_command(command, true)
  end
end


#
# Remove / Purge packages
#
# @param package  [String]  List of packages to remove / purge
# @param purge    [Boolean] True if purging packages else removing
#
# @return [void]
def remove(package, purge = false)
  if purge
    aptitude_string = `aptitude purge -VZs --assume-yes #{package}`
    command = "aptitude purge #{package}"

    operation = "Purging"
  else
    aptitude_string = `aptitude remove -VZs --assume-yes #{package}`
    command = "aptitude remove #{package}"

    operation = "Removing"
  end

  # if problem with dependencies, wrong name given,
  # or trying to remove a virtual package : display aptitude's message
  if (aptitude_string.include? "1)") or (aptitude_string.include? 'Â«')
    puts aptitude_string
    exit 0

  # if the package is not installed
  elsif not aptitude_string.include? ':'
    puts "Package(s) not installed."
    exit 0
  end

  # Remove the "p" paraleter on packages to purge
  aptitude_string.sub!(/\{p\}/, '')

  packages = []

  # split packages
  packages = aptitude_string.split(/ {2}/)

  if display_packages(packages, operation, $color_remove, operation + ' these packages', aptitude_string.split(/\n/)[-2])
    execute_command(command, true)
  end
end


#
# Print stats about packages.
#
# @return [void]
def stats
  packages_installed            = `dpkg --get-selections | grep install | grep -v deinstall | wc -l`
  packages_installed_explicitly = `aptitude search '~i !~M' | wc -l`
  cache_size                    = `du -sh /var/cache/apt/archives/ | cut -f 1`

  puts "#{`lsb_release -ds`}\n"

  puts "Total installed packages:         #{packages_installed}"
  puts "Explicitly installed packages:    #{packages_installed_explicitly}"
  puts "Space used by packages in cache:  #{cache_size}"
end


#
# Write configuration file.
#
# @param config_dir [String] Directory containing configuration file
#
# @return [void]
def write_config config_dir
  require "fileutils"

  config = "# colors\n" +
    "color_install      : \"\\e[1;32m\" # green\n" +
    "color_remove       : \"\\e[1;31m\" # red\n" +
    "color_description  : \"\\e[1;30m\" # gray\n\n" +
    "# config\n" +
    "display_packages_size  : true   # display or not the size of packages (only for install and remove)\n" +
    "spaces_between_columns : 2      # minimum 1\n" +
    "spaces_between_unit    : 1      # spaces between size and unit\n" +
    "spaces_search          : 40     # spaces with \"search\" between package name and his description\n" +
    "no_confirm             : false  # if true, don't ask for confirmation\n"


  if not File.directory? "#{config_dir}/apti"
    FileUtils.mkdir_p "#{config_dir}/apti"
  end

  File.open("#{config_dir}/apti/aptirc.yml", "w") do |f|
    f.write(config)
  end
end


#
# Read configuration file.
#
# @param config_dir [String] Directory containing configuration file
#
# @return [void]
def read_config config_dir
  require "yaml"

  app_config = YAML::load_file "#{config_dir}/apti/aptirc.yml"

  $color_install          = (app_config["color_install"] or "\e[1;32m")
  $color_remove           = (app_config["color_remove"] or "\e[1;31m")
  $color_description      = (app_config["color_description"] or "\e[1;30m")
  $display_packages_size  = (app_config["display_packages_size"] or true)
  $spaces_between_columns = (app_config["spaces_between_columns"] or 2)
  $spaces_between_unit    = (app_config["spaces_between_unit"] or 1)
  $spaces_search          = (app_config["spaces_search"] or 40)
  $no_confirm             = (app_config["no_confirm"] or false)
end


#
# Return the directory containing configuration file (configuration directory).
#
# @return [String] The path of directory
def get_config_dir
  if ENV["XDG_CONFIG_HOME"].nil?
    return "#{ENV["HOME"]}/.config"
  else
    return ENV["XDG_CONFIG_HOME"]
  end
end



#-----------------------------#
#          execution          #
#-----------------------------#

config_dir = get_config_dir

if not File.exist?("#{config_dir}/apti/aptirc.yml")
  write_config config_dir
end

read_config config_dir


packages = ""
first_argv_passed = false
ARGV.each do |package|
  if not first_argv_passed
    first_argv_passed = true
  else
    packages.concat " #{package}"
  end
end

case ARGV[0]

when "safe-upgrade"
  upgrade packages

when "upgrade"
  puts "Warning: upgrade is deprecated, use safe-upgrade."
  upgrade packages

when "full-upgrade"
  upgrade(packages, true)

when "search"
  search packages

when "update"
  execute_command "aptitude update"

when "remove"
  remove packages

when "purge"
  remove(packages, true)

when "install"
  install packages

when "stats"
  stats

when "--help"
  help
when "-h"
  help

when "--version"
  version

  # other aptitude command
else
  if not ARGV[0].eql? nil
    arg = ""
    ARGV.each do |ele|
      arg.concat "#{ele} "
    end
    execute_command "aptitude #{arg}"
  else
    help
  end

end
