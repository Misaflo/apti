#!/usr/bin/env ruby
# encoding: utf-8

=begin
****************************************************************************

  Apti is a frontend for aptitude with improved presentation of packages.

  Copyright (C) 2012 by Florent Lévigne <florent.levigne at mailoo dot com>
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

****************************************************************************
=end

APTI_VERSION      = "0.2.2-dev (2012-11-14)"

$VERBOSE          = true          # enable warnings

COLOR_INSTALL     = "\033[1;32m"  # green
COLOR_REMOVE      = "\033[1;31m"  # red
COLOR_DESCRIPTION = "\033[1;30m"  # gray
COLOR_END         = "\033[0m"

SPACES_SEARCH     = 40            # spaces with "search" between package name and his description


#-----------------------------#
#          functions          #
#-----------------------------#

#
# help
#
def help
  puts "usage: #{File.basename $0} commande"
  puts "Commandes:"
  puts "  update"
  puts "  safe-upgrade"
  puts "  search package"
  puts "  install package"
  puts "  remove package"
  puts "  others aptitude commande..."
  puts "  --stats"
end


#
# version
#
def version
  puts "apti #{APTI_VERSION}"
end


#
# Return an hash with largest size of package name (max["name"]),
# and largest size of package version (max["version"]).
#
def get_max_package packages 
  max_name_size     = 0
  max_version_size  = 0

  packages.each do |ele|
    if ele =~ /(([[:alnum:]]|-|\+|\.|\{|\})*) \[(([[:alnum:]]|-|\+|\.|:|~)*)/

      package_name    = $1
      package_version = $3

      if package_name.length > max_name_size
        max_name_size = package_name.length
      end

      if package_version.length > max_version_size
        max_version_size = package_version.length
      end

    end
  end

  max             = Hash.new
  max["name"]     = max_name_size
  max["version"]  = max_version_size

  return max
end


#
# Execute the command with sudo or su -c.
#
def execute_command command
  if `groups`.split.include? "sudo"
    system "sudo #{command}"
  else
    system "su -c '#{command}'"
  end
end


#
# upgrade
#
def upgrade full_upgrade = false
  if full_upgrade
    aptitude_string = `aptitude full-upgrade -Vs --allow-untrusted --assume-yes`
    command = "aptitude full-upgrade"
  else
    aptitude_string = `aptitude safe-upgrade -Vs --allow-untrusted --assume-yes`
    command = "aptitude safe-upgrade"
  end

  # if problem with dependencies, use aptitude
  if aptitude_string.include? "1)"
    execute_command command
    exit 0

  # if there is no package to upgrade
  elsif !aptitude_string.include? ':'
    puts "System is up to date."
    exit 0
  end

  packages = [[]]

  first_install = false
  first_remove  = false
  first_update  = false

  # split packages
  packages = aptitude_string.split ']'

  max             = get_max_package packages
  largest_name    = max["name"]
  largest_version = max["version"]

  packages.each do |ele|

    # if we have a package to install
    # ex: freepats{a} [20060219-1
    if ele =~ /(([[:alnum:]]|-|\+|\.)*\{a\}) \[(.*)/
      package_name    = $1
      package_version = $3

      if !first_install
        puts "\033[1mNew package(s) to install:\033[0m"
        first_install = true
      end

      print "install: #{package_name}"

      # print spaces between name and version of the package
      (largest_name - package_name.length).times do
        print ' '
      end

      puts " #{COLOR_INSTALL}#{package_version}#{COLOR_END}"

    # if we have a package to remove
    # ex: gcj-4.6-base{u} [4.6.3-1]
    elsif ele =~ /(([[:alnum:]]|-|\+|\.)*\{u\}) \[(.*)/
      package_name    = $1
      package_version = $3

      if !first_remove
        puts "\n\033[1mPackage(s) to remove:\033[0m"
        first_remove = true
      end

      print "remove: #{package_name} "

      # print spaces between name and version of the package
      (largest_name - package_name.length).times do
        print ' '
      end

      puts " #{COLOR_REMOVE}#{package_version}#{COLOR_END}"

    # if we have a package to upgrade
    # ex: php5 [5.3.10-2 -> 5.4.0-3
    elsif ele =~ /(([[:alnum:]]|-|\+|\.)*) \[(.*) -> (.*)/
      
      package_name        = $1
      version_installed   = $3
      version_to_install  = $4

      if !first_update
        puts "\n\033[1mPackage(s) to update:\033[0m"
        first_update = true
      end
      
      # package name
      print "update: #{package_name} "

      # print spaces between name and version of the package
      (largest_name - package_name.length).times do
        print ' '
      end

      # version installed
      print " #{COLOR_REMOVE}#{version_installed}#{COLOR_END} "

      # print spaces between version installed and version to install
      (largest_version - version_installed.length).times do
        print ' '
      end

      # version to install
      puts "-> #{COLOR_INSTALL}#{version_to_install}#{COLOR_END}"
    end
  end

  # size to download and install
  puts "\n#{aptitude_string.split(/\n/)[-2]}"

  answer = ''
  while !answer.downcase.eql? 'y' and !answer.downcase.eql? 'n'
    print "\n\033[1mContinue the upgrade ? (Y/n)\033[0m "
    answer = STDIN.gets.chomp
    if answer.empty?
      answer = 'y'
    end
  end

  if !answer.downcase.eql? 'n'
    execute_command command
  end
end


#
# search
#
def search package
  aptitude_string = `aptitude search --disable-columns #{package}`
  terminal_width  = `tput cols`.to_i
  package_info_length = 6 # information size (i, p, A, ...) : 6 seems to be good

  # for each package
  aptitude_string.each_line do |package|
    
    package_str = package.split "- "

    package_name = package_str.first # ex: i A aptitude-common
    package_description = ""

    # construct the description (all after the first '-')
    name_passed = false
    package_str.each do |str|
      if !name_passed
        name_passed = true
      else
        package_description.concat "- #{str }"
      end
    end

    # informations of the package: i, p, A, ...
    package_info = package_name.split
    package_info.pop
    package_info = package_info.join(' ')

    # just the package name (without informations)
    package_name = package_name.split.last

    # display package informations
    print package_info

    # print spaces between package_info and package_name
    (package_info_length - package_info.length).times do
      print ' '
    end

    # display package name: if the package is installed, we display it in color
    if package_info.include? 'i'
      print "#{COLOR_INSTALL}#{package_name}#{COLOR_END}"
    else
      print package_name
    end

    # print spaces between package_name and package_description
    (SPACES_SEARCH - package_name.length).times do
      print ' '
    end

    size_of_line = package_info_length + SPACES_SEARCH + package_description.length

    # if description is too long, we shorten it
    if size_of_line > terminal_width
      package_description = package_description[0..(terminal_width - package_info_length - SPACES_SEARCH - 1)]
    end
    
    # display the description
    puts "#{COLOR_DESCRIPTION}#{package_description.chomp}#{COLOR_END}"
  end
end


#
# install
#
def install package
  aptitude_string = `aptitude install -Vs --allow-untrusted --assume-yes #{package}`
  command = "aptitude install #{package}"

  # if problem with dependencies, wrong name given,
  # or trying to install a virtual package : use aptitude
  if aptitude_string.include? "1)" or aptitude_string.include? '«'
    execute_command command
    exit 0

  # if the package is already installed
  elsif !aptitude_string.include? ':'
    puts "Package(s) already installed."
    exit 0
  end

  packages = [[]]

  first_install = false

  # split packages
  packages = aptitude_string.split ']'

  max             = get_max_package packages
  largest_name    = max["name"]

  packages.each do |ele|

    # if we have a package to install
    # ex: freepats{a} [20060219-1 or freepats [20060219-1
    if ele =~ /(([[:alnum:]]|-|\+|\.|\{|\})*) \[(.*)/
      package_name    = $1
      package_version = $3

      if !first_install
        puts "\033[1mPackage(s) to install:\033[0m"
        first_install = true
      end

      print "install: #{package_name}"

      # print spaces between name and version of the package
      (largest_name - package_name.length).times do
        print ' '
      end
      
      puts " #{COLOR_INSTALL}#{package_version}#{COLOR_END}"

    end
  end

  # size to download and install
  puts "\n#{aptitude_string.split(/\n/)[-2]}"

  answer = ''
  while !answer.downcase.eql? 'y' and !answer.downcase.eql? 'n'
    print "\n\033[1mContinue the installation ? (Y/n)\033[0m "
    answer = STDIN.gets.chomp
    if answer.empty?
      answer = 'y'
    end
  end

  if !answer.downcase.eql? 'n'
    execute_command command
  end
end


#
# remove
#
def remove(package, purge = false)
  if purge
    aptitude_string = `aptitude purge -Vs --assume-yes #{package}`
    command = "aptitude purge #{package}"
  else
    aptitude_string = `aptitude remove -Vs --assume-yes #{package}`
    command = "aptitude remove #{package}"
  end

  # if problem with dependencies, wrong name given,
  # or trying to remove a virtual package : use aptitude
  if aptitude_string.include? "1)" or aptitude_string.include? '«'
    execute_command command
    exit 0

  # if the package is not installed
  elsif !aptitude_string.include? ':'
    puts "Package(s) not installed."
    exit 0
  end

  packages = [[]]

  first_remove = false

  # split packages
  packages = aptitude_string.split ']'

  max             = get_max_package packages
  largest_name    = max["name"]

  packages.each do |ele|

    # if we have a package to remove
    # ex: freepats{u} [20060219-1 or freepats [20060219-1
    if ele =~ /(([[:alnum:]]|-|\+|\.|\{|\})*) \[(.*)/
      package_name    = $1
      package_version = $3

      if !first_remove
        puts "\033[1mPackage(s) to remove:\033[0m"
        first_remove = true
      end

      print "remove: #{package_name}"

      # print spaces between name and version of the package
      (largest_name - package_name.strip.length).times do
        print ' '
      end
      
      puts " #{COLOR_REMOVE}#{package_version}#{COLOR_END}"

    end
  end

  # size free
  puts "\n#{aptitude_string.split(/\n/)[-2]}"

  answer = ''
  while !answer.downcase.eql? 'y' and !answer.downcase.eql? 'n'
    print "\n\033[1mRemove these packages ? (Y/n)\033[0m "
    answer = STDIN.gets.chomp
    if answer.empty?
      answer = 'y'
    end
  end

  if !answer.downcase.eql? 'n'
    execute_command command
  end
end


#
# Print stats about packages.
#
def stats
  packages_installed            = `dpkg --get-selections | grep install | grep -v deinstall | wc -l`
  packages_installed_explicitly = `aptitude search '~i !~M' | wc -l`
  cache_size                    = `du -sh /var/cache/apt/archives/ | cut -f 1`

  puts "#{`lsb_release -ds`}\n"

  puts "Total installed packages:         #{packages_installed}"
  puts "Explicitly installed packages:    #{packages_installed_explicitly}"
  puts "Space used by packages in cache:  #{cache_size}"
end



#-----------------------------#
#          execution          #
#-----------------------------#

packages = ""
first_argv_passed = false
ARGV.each do |package|
  if !first_argv_passed
    first_argv_passed = true
  else
    packages.concat " #{package}"
  end
end

case ARGV[0]

  when "safe-upgrade"
    upgrade

  when "upgrade"
    puts "Warning: upgrade is deprecated, use safe-upgrade."
    upgrade

  when "full-upgrade"
    upgrade true

  when "search"
    search packages

  when "update"
    execute_command "aptitude update"

  when "remove"
    remove packages

  when "purge"
    remove(packages, true)

  when "install"
    install packages

  when "--stats"
    stats

  when "--help"
    help

  when "--version"
    version

  # other aptitude command
  else
    if ARGV[0] != nil
      arg = ""
      ARGV.each do |ele|
        arg.concat "#{ele} "
      end
      system "aptitude #{arg}"
    else
      help
    end

end
